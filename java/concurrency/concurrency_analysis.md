# 병렬 프로그래밍

여러 작업을 동시에 진행해야 하는 경우가 있다. 프로세스는 프로그램이 메인메모리에 올라가는 순간 그 생명이 시작되므로 하나의 프로그램은 하나의 프로세스를 이룬다. 하나의 프로그램 안에는 그 프로그램이 제공하는 여러 행위들이 구현되어 있다. 그러한 행위들은 순차적으로 이뤄지기도 하지만 병렬적으로 이루어지는 경우도 있다. 뮤직플레이어 프로그램을 생각해보자. 소리를 내보내는 행위와 영상을 내보내는 행위는 같은 메커니즘으로 동작하지 않으며 각자의 메커니즘에 따라 병렬적으로 행동한다.

## 프로세스와 쓰레드

프로세스는 보조기억장치에 있던 프로그램이 메인메모리에 올라갔을 때 프로세스가 된다고 한다. 그렇다면 프로세스는 무엇일까? 프로세스는 실행 흐름의 단위(메인실행 흐름)이며 JVM이 프로세스가 될 수도 있고 JVM의 GC가 프로세스가 될 수도 있다. 이는 관점의 차이에서 발생하는 현상인데 사용자 레벨에서의 프로세스는 하나의 실행가능한 프로그램이 메인메모리에 올라 실행될 때 하나의 단위로서 일컫을 수 있다. 하지만 커널 레벨에서는 사용자레벨에서 하나의 프로세스로 인식되는 것이 여러 개의 프로세스로 해석된다.

## Thread vs Light Weight Process

쓰레드는 유저 관점에서 봤을 때 프로세스 내에서 실행 흐름의 단위인 추상적인 개념이다. 하지만 커널은 쓰레드라는 개념이 없고 실행 단위가 프로세스이기 때문에 이러한 쓰레드들은 LWP로 해석되어 커널에서 사용된다. LWP는 이 때 메모리 등의 데이터를 공유하게 되어 데이터를 공유하지 않는 프로세스에 비해 가볍기에 ligth weight process라고 불리우는 것이다. context switching 관점에서 봤을 때 물리적인 코어는 문맥 전환시에 레지스터와 캐시를 PCB에 저장 후 다른 프로세스의 정보를 저장하게 되는데 LWP의 경우 교체해야 하는 데이터의 양이 적기 때문에 문맥전환비용이 낮다고 해석할 수 있다. 따라서 OS 스케줄러는 LWP끼리 문맥전환을 시킴으로써 비용을 줄이는 방식을 선택할 수 있다.

![ligthweight](https://docs.oracle.com/cd/E19683-01/806-6867/images/mtintro.fig33.epsi.gif)
## 결국 멀티쓰레드 환경에서 발생하는 일은 무엇일까?

1. 사용자의 추상화된 실행 흐름을 쓰레드로 추상화한다.
2. 이러한 쓰레드는 커널 레벨로 가게 되면 LWP로 해석된다. 이 때 여러개의 쓰레드가 하나의 LWP로 묶이기도 한다.
3. LWP는 커널 레벨에서 공유하는 데이터가 있는 프로세스를 말하며 문맥전환 비용이 낮다.

결국 사용자가 만든 쓰레드는 OS에 의해서 LWP로 해석되며 더 좋은 성능을 낼 수도 있고 아닐 수도 있다. 아닐 수도 있는 이유는 결국 LWP도 문맥전환 비용이 있기 때문에 하나의 프로세스로 구성하는 것과 비교했을 때 항상 효율적이라고 얘기할 수는 없다. 또한 내부적으로 OS스케줄링이나 LWP해석에서의 변수 또한 고려해야 하므로 지표를 잘 측정하여 사용하는 것이 중요하다(자바 최적화).

## 동기화

### 동기 처리 비동기 처리

둘다 처리 방식의 일종으로 동기처리는

1. 같은 자원을 공유하여 한번에 한 쓰레드만 접근할 수 있게하거나
2. 순차적으로 처리하고 싶을 때 사용하고 비동기처리는 그러한 제한없이 병렬적으로 처리할 수 있을 때 사용한다.

비동기처리의 경우 병렬적으로 처리하기 때문에 동기처리에 비해 처리 속도는 빠를 수 있으나 동시성 이슈를 고려해야 한다. 그에 반해 동기 처리는 동시성 이슈를 고려하지 않아도 된다.

동기와 비동기의 차이가 호출되는 함수의 작업완료 여부를 신경쓰는지 여부라고 하는 글이 많다. 이는 2번의 경우 맞는 말이다. 하지만 순차적으로 처리하기 위해서 동기 처리를 선택한 것은 맞지만 동기의 특성이라고 보기는 어렵다. 그저 동기처리가 순차적인 처리에 적합하기 때문에 사용된 것이다. 논블로킹 동기처리의 경우 계속 결과를 확인한다고 하지만 이는 논블로킹에서 오는 특성인것이 크다. 이미 리턴을 하고 다른 작업을 하고 있기 때문에 동기화 처리가 필요한 기존 작업을 수행하기 위해서는 계속 확인이 필요한 것이 당연하다.

### 블로킹 논블로킹

함수제어 흐름 관점과 쓰레드 관점이 있다. 함수제어에서는 다른 메소드를 호출했을 때 호출한 메소드가 호출당한 메소드의 종료 혹은 결과를 기다리는 것을 블로킹이라고 하고 리턴하고 지속적인 확인을 통해 나중에 결과를 받는 것을 논블로킹이라고 한다. (ex. CAS)쓰레드 관점에서는 쓰레드가 다른 쓰레드가 실행됨에 따라 블록 당했을 때 블로킹, 다른 쓰레드를 기다리지 않고 작업을 수행하는 것을 논블로킹이라고 한다.

### 동시성 이슈

실행 흐름을 굳이 만들어서 얻는 효용은 무엇일까? 만약 다른 쓰레드가 존재하지 않고 하나의 메인 쓰레드에서 하나의 실행 흐름만이 있다고 생각해보자. 모든 명령어들은 순차적으로 실행될 것이고 만약 앞에 호출된 메소드가 종료되지 않는다면 그 뒤에 있는 메소드들은 당연히 기다려야 할 것이다. 이 때 실행흐름을 추가해준다면 뒤에 진행될 실행흐름을 병행하여 실행할 수 있고 실행속도를 늘릴 수 있다는 것이다.

하지만 실행흐름들이 여러개가 생겼을 때 발생할 수 있는 문제가 동시성 이슈이다. 동시성이란 실제로는 동시로 일어나고 있지 않은 실행흐름들이 동시에 일어나는 것처럼 보이는 것을 말하는데 여기서 발생할 수 있는 문제들을 일컫어 동시성 이슈라고 부른다. 동시성 이슈에는

1. 동시 접근 문제(race condition)
2. 가시성 문제(visablity)

가 존재한다. 동시접근 문제는 여러 쓰레드가 동시에 공유 데이터에 접근하여 변경할 때 발생할 수 있는 문제로 연산의 원자성이 지켜지지 않을 생기는 문제다. 원자적인 연산은 한번 수행되면 그 결과가 반영되지만 비원자적 연산은 그렇지 않을 수 있다. count++를 예를 들면 count 값을 읽고, 연산하고, 저장하는 3가지 과정으로 이루어지는데 이 과정은 원자적 연산이 아니기 때문에 다른 쓰레드가 연산한 값이 무시된다. **즉 동시 접근 문제는 연산의 원자성이 지켜지지 않는 결과를 낳는다.**

가시성 문제는 사용하는 데이터가 최신이 아님을 의미하며 이는 volatile 키워드를 이용하면 데이터를 캐시가 아닌 메인메모리에 올려 항상 최신화하기 때문에 읽는 쓰레드들은 항상 최신값을 받아올 수 있다. 이 때 쓰는 쓰레드는 하나여야 하고 그 이상이면 동시접근 문제를 낳게 된다. 또한 volatile 키워드는 키워드가 붙은 데이터뿐만 아니라 다른 데이터도 메인 메모리에 올리는 full visablity를 제공한다.

java.util.concurrent 패키지에서는 이러한 동시성 이슈를 해결하기 위한 여러가지 클래스들을 제공한다.

- AtomicType
- ReentrantLock
- ExecutorService
- CountDownLatch
- CyclicBarrier
- BlockingQueue
- Future

재미있는 내용들이 많으나 자세한 정보는 링크에 남겨두는 것이 좋을 듯하다.

https://www.baeldung.com/java-util-concurrent

### 동시성 이슈 해결 수단으로서의 동기화

동시성 이슈를 해결하기 가장 쉬운 방법은 동기처리를 이용하는 것이다. 동시성 이슈는 결국 비동기 처리방식에서 기인하는 것이고 동기 처리에서는 발생하지 않기 때문이다.

### ThreadLocal

Thread locally 사용가능한 변수를 말하며 ThreadLocal 객체 생성 후 get(), set(), remove() 등이 가능하다.

- 사용자 인증정보 전파 - Spring Security에서는 ThreadLocal을 이용해서 사용자 인증 정보를 전파
- 트랜잭션 컨텍스트 전파 - 트랜잭션 매니저는 트랜잭션 컨텍스트를 전파하는 데 ThreadLocal을 사용
- 쓰레드에 안전해야 하는 데이터 보관

등에 사용된다. 다만 쓰레드풀 환경에서 데이터의 사용이 끝나면 꼭 삭제해주어야 재사용된 쓰레드가 올바른 데이터를 참조할 수 있다.

### 참고 자료

lwp

* https://www.thegeekstuff.com/2013/11/linux-process-and-threads/
* https://docs.oracle.com/cd/E19455-01/806-5257/mtintro-72944/index.html
* https://www.youtube.com/watch?v=1grtWKqTn50\

Java Thread vs OS Thread

* https://www.geeksforgeeks.org/difference-between-java-threads-and-os-threads/

하이퍼쓰레딩

* https://en.wikipedia.org/wiki/Hyper-threading

고유락

* http://happinessoncode.com/2017/10/04/java-intrinsic-lock/

쓰레드 간 통신(고유락을 이용한 wait(), notify(), notifyAll())

* https://www.geeksforgeeks.org/inter-thread-communication-java/

* http://happinessoncode.com/2017/10/05/java-object-wait-and-notify/

쓰레드로컬

* https://javacan.tistory.com/entry/ThreadLocalUsage